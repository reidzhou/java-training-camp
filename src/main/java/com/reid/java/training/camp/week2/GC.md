# GC总结

## GC策略
### 串行GC
年轻代使用`标记-复制`策略，老年代使用`标记-清除-整理`策略
业务线程和GC线程串行执行，GC执行过程中业务不可用，对于的程序的影响较大
单核环境下且小内存应用可以使用串行策略
### 并行GC
年轻代使用`标记-复制`策略，老年代使用`标记-清除-整理`策略
并行GC与串行GC的主要不同点在于，并行GC充分利用了多核的优势，GC操作都是并发执行，大大的降低了GC过程中的STW时间，并且在GC间隔期间GC线程不会运行，避免系统资源的无谓消耗
### CMS
年轻代使用`标记-复制`策略，老年代使用`标记-清除`策略
CMS主要优化了老年代的GC策略，将原先一次执行到底的GC操作分为多个步骤，极大地降低了STW时间，并且对于老年代的内存不再执行整理操作
因此CMS有一个很明显的缺点，就是老年代内存碎片化问题，对于内存对象都比较大的应用来说，这是比较致命的
### G1
G1不再基于内存划分物理概念上的年轻代和老年代，而是划分成多个可以存放对象的小堆区，基于小堆区的内存使用情况来标记它是属于年轻代还是老年代
基于G1的这一特性，G1就可以控制每次垃圾回收所涉及到的内存区域，进而控制每次垃圾回收所消耗的时间
G1有一个参数可以设置暂停时间目标，这个参数不应当设置过小，否则会造成每次GC回收的垃圾太小，从而频繁地触发Full GC

## GC优化
GC优化主要从两个方向入手，降低GC频率和减少GC停顿时间
由于GC过程中总是会有STW，所以应该尽可能地降低GC频率，可以使用的优化措施有增加堆内存。
由于Full GC的代价比Young GC要大，因此要尽可能地避免触发Full GC，可以使用的优化措施有增大老年代内存、增大年轻代对象晋升老年代的阈值、增大大内存对象直接分配老年代的阈值。
但是增大内存又会带来另一个问题，那就是GC的时候垃圾过多，导致GC执行时间过长，使得应用在一个较长的时间内不可用。

GC优化并没有一个标准可用的方案，需要根据应用的具体环境、内存对象的具体情况来做一个GC频率与GC停顿时间之间的平衡，达到一个相对理想的运行状况。